# 描述符用法建议

## 使用特性保持简单

内置的 property 类创建的其实是覆盖型描述符，`__set__` 方法和 `__get__` 方法都实现了，特性的 `__set__` 方法默认抛出 AttributeError: can't set attribute。因此创建只读属性最简单的方式是使用特性。

## 只读描述符必须有 `__set__` 方法

如果使用描述符类实现只读属性，要记住，`__get__` 和 `__set__` 。否则，实例的同名属性会遮盖描述符。只读属性的 `__set__` 方法只需抛出 AttributeError 异常，并提供合适的错误消息。

## 用于验证的描述符可以只有 `__set__` 方法

对仅用于验证的描述符来说，`__set__` 方法应该检查 value 参数获得的值，如果有效，使用描述符实例的名称为键，直接在实例的 `__dict__` 属性中设置。

## 仅有 `__get__` 方法的描述符可以实现高效缓存

如果只编写了 `__get__` 方法，那么创建的是非覆盖型描述符。这种描述符可用于执行某些耗费资源的计算，然后为实例设置同名属性，缓存结果。同名实例属性会遮盖描述符，因此后续访问会直接从实例的 `__dict__` 属性中获取值，而不会再触发描述符的 `__get__` 方法。

## 非特殊的方法可以被实例属性遮盖

由于函数和方法只实现了 `__get__` 方法，他们不会处理同名实例属性的赋值操作。因此像 `my_obj.the_method = 9` 这样简单赋值之后，后续通过该实例访问 the_method 得到的是数字 7 — 但是不影响类或其他实例。然后，特殊方法不受这个问题的影响。解释器只会在类中寻找特殊的方法，也就是说，`repr(x)` 执行的其实是 `x.__class__.__repr__(x)` ，因此 x 的 `__repr__` 属性对 `repr(x)` 方法调用没有影响。出于同样的原因，实例的 `__getattr__` 属性不会破坏常规的属性访问规则。